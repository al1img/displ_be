/*
 *  Drm class
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 *
 * Copyright (C) 2016 EPAM Systems Inc.
 *
 */

#ifndef INCLUDE_DRM_HPP_
#define INCLUDE_DRM_HPP_

#include <exception>
#include <functional>
#include <map>
#include <memory>
#include <mutex>
#include <string>
#include <thread>
#include <vector>

#include <xf86drm.h>
#include <xf86drmMode.h>
#include <drm_fourcc.h>

#include <xen/be/Log.hpp>

namespace Drm {

class DrmDevice;

extern const uint32_t cInvalidId;

/***************************************************************************//**
 * Exception generated by Drm.
 ******************************************************************************/
class DrmException : public std::exception
{
public:
	/**
	 * @param msg error message
	 */
	explicit DrmException(const std::string& msg) : mMsg(msg) {};

	/**
	 * returns error message
	 */
	const char* what() const throw() { return mMsg.c_str(); };

private:
	std::string mMsg;
};

class ModeResource
{
public:
	ModeResource(int fd);
	~ModeResource();
	ModeResource(const ModeResource&) = delete;
	ModeResource& operator=(ModeResource const&) = delete;

	const drmModeResPtr operator->() const;
	const drmModeRes& operator*() const;

private:
	drmModeResPtr mRes;
};

class ModeConnector
{
public:
	ModeConnector(int fd, int connectorId);
	~ModeConnector();
	ModeConnector(const ModeConnector&) = delete;
	ModeConnector& operator=(ModeConnector const&) = delete;

	const drmModeConnectorPtr operator->() const;
	const drmModeConnector& operator*() const;

private:
	drmModeConnectorPtr mConnector;
};

class ModeEncoder
{
public:
	ModeEncoder(int fd, int encoderId);
	~ModeEncoder();
	ModeEncoder(const ModeEncoder&) = delete;
	ModeEncoder& operator=(ModeEncoder const&) = delete;

	const drmModeEncoderPtr operator->() const;
	const drmModeEncoder& operator*() const;

private:
	drmModeEncoderPtr mEncoder;
};

class Dumb
{
public:
	Dumb(DrmDevice& drm, uint32_t width, uint32_t height, uint32_t bpp);
	~Dumb();

	uint32_t getWidth() const { return mWidth; }
	uint32_t getHeight() const { return mHeight; }
	uint32_t getHandle() const { return mHandle; }
	uint32_t getPitch() const { return mPitch; }
	uint32_t getSize() const { return mSize; }
	void* getBuffer() const { return mBuffer; }

private:
	DrmDevice& mDrm;
	uint32_t mHandle;
	uint32_t mPitch;
	uint32_t mWidth;
	uint32_t mHeight;
	uint64_t mSize;
	void* mBuffer;

	void release();
};

typedef std::function<void()> FlipCallback;

class FrameBuffer
{
public:

	FrameBuffer(DrmDevice& drm, Dumb& dumb, uint32_t width, uint32_t height,
				uint32_t pixelFormat, uint32_t pitch);
	~FrameBuffer();

	uint32_t getId() const { return mId; }
	Dumb& getDumb() const { return mDumb; }
	uint32_t getHandle() const { return mDumb.getHandle(); }

	bool pageFlip(uint32_t crtc, FlipCallback cbk);

private:
	DrmDevice& mDrm;
	Dumb& mDumb;
	uint32_t mId;
	std::atomic_bool mFlipPending;
	FlipCallback mFlipCallback;

	friend class DrmDevice;

	void flipFinished();
};

class Connector
{
public:

	Connector(DrmDevice& dev, int connectorId);
	~Connector();

	uint32_t getCrtcId() const { return mCrtcId; }
	uint32_t getId() const { return mConnector->connector_id; }
	bool isConnected() const { return mConnector->connection ==
									  DRM_MODE_CONNECTED;
	}

	bool isInitialized() const { return mCrtcId != cInvalidId; }

	void init(uint32_t x, uint32_t y, uint32_t width, uint32_t height,
			  uint32_t bpp, uint32_t fbId);
	void release();

private:
	DrmDevice& mDev;
	int mFd;
	uint32_t mCrtcId;
	ModeConnector mConnector;
	drmModeCrtc* mSavedCrtc;
	XenBackend::Log mLog;

	uint32_t findCrtcId();
	uint32_t getAssignedCrtcId();
	uint32_t findMatchingCrtcId();
	bool isCrtcIdUsedByOther(uint32_t crtcId);
	drmModeModeInfoPtr findMode(uint32_t width, uint32_t height);
};

class DrmDevice
{
public:
	DrmDevice(const std::string& name);
	~DrmDevice();

	int getFd() const { return mFd; }

	int getCtrcsCount() const { return (*mRes)->count_crtcs; }
	uint32_t getCtrcIdByIndex(int index) const { return (*mRes)->crtcs[index]; }

	Connector& getConnectorById(uint32_t id);
	Connector& getConnectorByIndex(uint32_t index);
	size_t getConnectorsCount();

	void start();
	void stop();

	Dumb& createDumb(uint32_t width, uint32_t height,
									 uint32_t bpp);
	void deleteDumb(uint32_t handle);

	FrameBuffer& createFrameBuffer(Dumb& dumb, uint32_t width,
								   uint32_t height, uint32_t pixelFormat);
	void deleteFrameBuffer(uint32_t id);

private:

	const int cPoolEventTimeoutMs = 100;

	std::string mName;
	int mFd;
	std::atomic_bool mTerminate;
	std::atomic_int mNumFlipPages;
	XenBackend::Log mLog;

	std::unique_ptr<ModeResource> mRes;

	std::map<uint32_t, std::unique_ptr<Connector>> mConnectors;
	std::map<uint32_t, std::unique_ptr<Dumb>> mDumbs;
	std::map<uint32_t, std::unique_ptr<FrameBuffer>> mFrameBuffers;

	std::mutex mMutex;
	std::thread mThread;

	void init();
	void release();
	void eventThread();

	static void handleFlipEvent(int fd, unsigned int sequence,
								unsigned int tv_sec, unsigned int tv_usec,
								void *user_data);

	friend class FrameBuffer;

	bool isStopped() { return mTerminate; }
	void pageFlipScheduled() { mNumFlipPages++; }
	void pageFlipDone() { mNumFlipPages--; }
};

}

#endif /* INCLUDE_DRM_HPP_ */
